// !Generated by regml2cpp!
#ifndef __RCC_INCLUDED
#define __RCC_INCLUDED

#include <stmlib/bits.hpp>

namespace rcc { 
    namespace fields {
        // RCC clock control register [offset: 0x00, reset: 0x0000]
        namespace cr {
            // PLLI2S clock ready flag (rm page 220)
            using plli2srdy = bit::field<27>;
            // PLLI2S enable (rm page 220)
            using plli2son = bit::field<26>;
            // Main PLL (PLL) clock ready flag (rm page 220)
            using pllrdy = bit::field<25>;
            // Main PLL (PLL) enable (rm page 220)
            using pllon = bit::field<24>;
            // Clock security system enable (rm page 220)
            using csson = bit::field<19>;
            // HSE clock bypass (rm page 221)
            using hsebyp = bit::field<18>;
            // HSE clock ready flag (rm page 221)
            using hserdy = bit::field<17>;
            // HSE clock enable (rm page 221)
            using hseon = bit::field<16>;
            // Internal high-speed clock calibration (rm page 221)
            using hsical = bit::field<15, 8>;
            // Internal high-speed clock trimming (rm page 221)
            using hsitrim = bit::field<7, 3>;
            // Internal high-speed clock ready flag (rm page 221)
            using hsirdy = bit::field<1>;
            // Internal high-speed clock enable (rm page 221)
            using hsion = bit::field<0>;
        }
        // RCC PLL configuration register [offset: 0x04, reset: 0x2400 3010]
        namespace pllcfgr {
            // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator (rm page 222)
            using pllq = bit::field<27, 24>;
            // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source (rm page 222)
            using pllsrc = bit::field<22>;
            // Main PLL (PLL) division factor for main system clock (rm page 223)
            using pllp = bit::field<17, 16>;
            // Main PLL (PLL) multiplication factor for VCO (rm page 223)
            using plln = bit::field<14, 6>;
            // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock (rm page 223)
            using pllm = bit::field<5, 0>;
        }
        // RCC clock configuration register [offset: 0x08, reset: 0x0000 0000]
        namespace cfgr {
            // Microcontroller clock output 2 (rm page 224)
            using mco2 = bit::field<31, 30>;
            // MCO2 prescaler (rm page 224)
            using mco2pre = bit::field<29, 27>;
            // MCO1 prescaler (rm page 224)
            using mco1pre = bit::field<26, 24>;
            // I2S clock selection (rm page 224)
            using i2ssrc = bit::field<23>;
            // Microcontroller clock output 1 (rm page 225)
            using mco1 = bit::field<22, 21>;
            // HSE division factor for RTC clock (rm page 225)
            using rtcpre = bit::field<20, 16>;
            // APB high-speed prescaler (APB2) (rm page 225)
            using ppre2 = bit::field<15, 13>;
            // APB Low speed prescaler (APB1) (rm page 225)
            using ppre1 = bit::field<12, 10>;
            // AHB prescaler (rm page 226)
            using hpre = bit::field<7, 4>;
            // System clock switch status (rm page 226)
            using sws = bit::field<3, 2>;
            // System clock switch (rm page 226)
            using sw = bit::field<1, 0>;
        }
        // RCC clock interrupt register [offset: 0x0C, reset: 0x0000 0000]
        namespace cir {
            // Clock security system interrupt clear (rm page 227)
            using cssc = bit::field<23>;
            // PLLI2S ready interrupt clear (rm page 227)
            using plli2srdyc = bit::field<21>;
            // Main PLL(PLL) ready interrupt clear (rm page 227)
            using pllrdyc = bit::field<20>;
            // HSE ready interrupt clear (rm page 227)
            using hserdyc = bit::field<19>;
            // HSI ready interrupt clear (rm page 227)
            using hsirdyc = bit::field<18>;
            // LSE ready interrupt clear (rm page 227)
            using lserdyc = bit::field<17>;
            // LSI ready interrupt clear (rm page 227)
            using lsirdyc = bit::field<16>;
            // PLLI2S ready interrupt enable (rm page 227)
            using plli2srdyie = bit::field<13>;
            // Main PLL (PLL) ready interrupt enable (rm page 227)
            using pllrdyie = bit::field<12>;
            // HSE ready interrupt enable (rm page 227)
            using hserdyie = bit::field<11>;
            // HSI ready interrupt enable (rm page 228)
            using hsirdyie = bit::field<10>;
            // LSE ready interrupt enable (rm page 228)
            using lserdyie = bit::field<9>;
            // LSI ready interrupt enable (rm page 228)
            using lsirdyie = bit::field<8>;
            // Clock security system interrupt flag (rm page 228)
            using cssf = bit::field<7>;
            // PLLI2S ready interrupt flag (rm page 228)
            using plli2srdyf = bit::field<5>;
            // Main PLL (PLL) ready interrupt flag (rm page 228)
            using pllrdyf = bit::field<4>;
            // HSE ready interrupt flag (rm page 228)
            using hserdyf = bit::field<3>;
            // HSI ready interrupt flag (rm page 229)
            using hsirdyf = bit::field<2>;
            // LSE ready interrupt flag (rm page 229)
            using lserdyf = bit::field<1>;
            // LSI ready interrupt flag (rm page 229)
            using lsirdyf = bit::field<0>;
        }
        // RCC AHB1 peripheral reset register [offset: 0x10, reset: 0x0000 0000]
        namespace ahb1rstr {
            // USB OTG HS module reset (rm page 229)
            using otghsrst = bit::field<29>;
            // Ethernet MAC reset (rm page 229)
            using ethmacrst = bit::field<25>;
            // DMA2 reset (rm page 230)
            using dma2rst = bit::field<22>;
            // DMA1 reset (rm page 230)
            using dma1rst = bit::field<21>;
            // CRC reset (rm page 230)
            using crcrst = bit::field<12>;
            // IO port I reset (rm page 230)
            using gpioirst = bit::field<8>;
            // IO port H reset (rm page 230)
            using gpiohrst = bit::field<7>;
            // IO port F reset (rm page 230)
            using gpiofrst = bit::field<5>;
            // IO port E reset (rm page 230)
            using gpioerst = bit::field<4>;
            // IO port D reset (rm page 230)
            using gpiodrst = bit::field<3>;
            // IO port C reset (rm page 231)
            using gpiocrst = bit::field<2>;
            // IO port B reset (rm page 231)
            using gpiobrst = bit::field<1>;
            // IO port A reset (rm page 231)
            using gpioarst = bit::field<0>;
        }
        // RCC AHB2 peripheral reset register [offset: 0x14, reset: 0x0000 0000]
        namespace ahb2rstr {
            // USB OTG FS module reset (rm page 232)
            using otgfsrst = bit::field<7>;
            // Random number generator module reset (rm page 232)
            using rngrst = bit::field<6>;
            // Hash module reset (rm page 232)
            using hashrst = bit::field<5>;
            // Cryptographic module reset (rm page 232)
            using cryprst = bit::field<4>;
            // Camera interface reset (rm page 232)
            using dcmirst = bit::field<0>;
        }
        // RCC AHB3 peripheral reset register [offset: 0x18, reset: 0x0000 0000]
        namespace ahb3rstr {
            // Flexible static memory controller module reset (rm page 233)
            using fsmcrst = bit::field<0>;
        }
        // RCC APB1 peripheral reset register [offset: 0x20, reset: 0x0000 0000]
        namespace apb1rstr {
            // DAC reset (rm page 233)
            using dacrst = bit::field<29>;
            // Power interface reset (rm page 233)
            using pwrrst = bit::field<28>;
            // CAN2 reset (rm page 234)
            using can2rst = bit::field<26>;
            // CAN1 reset (rm page 234)
            using can1rst = bit::field<25>;
            // I2C3 reset (rm page 234)
            using i2c3rst = bit::field<23>;
            // I2C2 reset (rm page 234)
            using i2c2rst = bit::field<22>;
            // I2C1 reset (rm page 234)
            using i2c1rst = bit::field<21>;
            // UART5 reset (rm page 234)
            using uart5rst = bit::field<20>;
            // USART4 reset (rm page 234)
            using uart4rst = bit::field<19>;
            // USART3 reset (rm page 234)
            using usart3rst = bit::field<18>;
            // USART2 reset (rm page 234)
            using usart2rst = bit::field<17>;
            // SPI3 reset (rm page 234)
            using spi3rst = bit::field<15>;
            // SPI2 reset (rm page 234)
            using spi2rst = bit::field<14>;
            // Window watchdog reset (rm page 235)
            using wwdgrst = bit::field<11>;
            // TIM14 reset (rm page 235)
            using tim14rst = bit::field<8>;
            // TIM13 reset (rm page 235)
            using tim13rst = bit::field<7>;
            // TIM12 reset (rm page 235)
            using tim12rst = bit::field<6>;
            // TIM7 reset (rm page 235)
            using tim7rst = bit::field<5>;
            // TIM6 reset (rm page 235)
            using tim6rst = bit::field<4>;
            // TIM5 reset (rm page 235)
            using tim5rst = bit::field<3>;
            // TIM4 reset (rm page 235)
            using tim4rst = bit::field<2>;
            // TIM3 reset (rm page 235)
            using tim3rst = bit::field<1>;
            // TIM2 reset (rm page 235)
            using tim2rst = bit::field<0>;
        }
        // RCC APB2 peripheral reset register [offset: 0x24, reset: 0x0000 0000]
        namespace apb2rstr {
            // TIM11 reset (rm page 236)
            using tim11rst = bit::field<18>;
            // TIM10 reset (rm page 236)
            using tim10rst = bit::field<17>;
            // TIM9 reset (rm page 236)
            using tim9rst = bit::field<16>;
            // System configuration controller reset (rm page 236)
            using syscfgrst = bit::field<14>;
            // SPI1 reset (rm page 236)
            using spi1rst = bit::field<12>;
            // SDIO reset (rm page 236)
            using sdiorst = bit::field<11>;
            // ADC interface reset (common to all ADCs) (rm page 237)
            using adcrst = bit::field<8>;
            // USART6 reset (rm page 237)
            using usart6rst = bit::field<5>;
            // USART1 reset (rm page 237)
            using usart1rst = bit::field<4>;
            // TIM8 reset (rm page 237)
            using tim8rst = bit::field<1>;
            // TIM1 reset (rm page 237)
            using tim1rst = bit::field<0>;
        }
        // RCC AHB1 peripheral clock enable register [offset: 0x30, reset: 0x0010 0000]
        namespace ahb1enr {
            // USB OTG HSULPI clock enable (rm page 238)
            using otghsulpien = bit::field<30>;
            // USB OTG HS clock enable (rm page 238)
            using otghsen = bit::field<29>;
            // Ethernet PTP clock enable (rm page 238)
            using ethmacptpen = bit::field<28>;
            // Ethernet Reception clock enable (rm page 238)
            using ethmacrxen = bit::field<27>;
            // Ethernet Transmission clock enable (rm page 238)
            using ethmactxen = bit::field<26>;
            // Ethernet MAC clock enable (rm page 238)
            using ethmacen = bit::field<25>;
            // DMA2 clock enable (rm page 238)
            using dma2en = bit::field<22>;
            // DMA1 clock enable (rm page 239)
            using dma1en = bit::field<21>;
            // CCM data RAM clock enable (rm page 239)
            using ccmdataramen = bit::field<20>;
            // Backup SRAM interface clock enable (rm page 239)
            using bkpsramen = bit::field<18>;
            // CRC clock enable (rm page 239)
            using crcen = bit::field<12>;
            // IO port I clock enable (rm page 239)
            using gpioien = bit::field<8>;
            // IO port H clock enable (rm page 239)
            using gpiohen = bit::field<7>;
            // IO port G clock enable (rm page 239)
            using gpiogen = bit::field<6>;
            // IO port F clock enable (rm page 239)
            using gpiofen = bit::field<5>;
            // IO port E clock enable (rm page 239)
            using gpioeen = bit::field<4>;
            // IO port D clock enable (rm page 239)
            using gpioden = bit::field<3>;
            // IO port C clock enable (rm page 240)
            using gpiocen = bit::field<2>;
            // IO port B clock enable (rm page 240)
            using gpioben = bit::field<1>;
            // IO port A clock enable (rm page 240)
            using gpioaen = bit::field<0>;
        }
        // RCC AHB2 peripheral clock enable register [offset: 0x34, reset: 0x0000 0000]
        namespace ahb2enr {
            // USB OTG FS clock enable (rm page 240)
            using otgfsen = bit::field<7>;
            // Random number generator clock enable (rm page 240)
            using rngen = bit::field<6>;
            // Hash modules clock enable (rm page 240)
            using hashen = bit::field<5>;
            // Cryptographic modules clock enable (rm page 241)
            using crypen = bit::field<4>;
            // Camera interface enable (rm page 241)
            using dcmien = bit::field<0>;
        }
        // RCC AHB3 peripheral clock enable register [offset: 0x38, reset: 0x0000 0000]
        namespace ahb3enr {
            // Flexible static memory controller module clock enable (rm page 241)
            using fsmcen = bit::field<0>;
        }
        // RCC APB1 peripheral clock enable register [offset: 0x40, reset: 0x0000 0000]
        namespace apb1enr {
            // DAC interface clock enable (rm page 242)
            using dacen = bit::field<29>;
            // Power interface clock enable (rm page 242)
            using pwren = bit::field<28>;
            // CAN 2 clock enable (rm page 242)
            using can2en = bit::field<26>;
            // CAN 1 clock enable (rm page 242)
            using can1en = bit::field<25>;
            // I2C3 clock enable (rm page 242)
            using i2c3en = bit::field<23>;
            // I2C2 clock enable (rm page 242)
            using i2c2en = bit::field<22>;
            // I2C1 clock enable (rm page 242)
            using i2c1en = bit::field<21>;
            // UART5 clock enable (rm page 242)
            using uart5en = bit::field<20>;
            // UART4 clock enable (rm page 242)
            using uart4en = bit::field<19>;
            // USART3 clock enable (rm page 242)
            using usart3en = bit::field<18>;
            // USART2 clock enable (rm page 243)
            using usart2en = bit::field<17>;
            // SPI3 clock enable (rm page 243)
            using spi3en = bit::field<15>;
            // SPI2 clock enable (rm page 243)
            using spi2en = bit::field<14>;
            // Window watchdog clock enable (rm page 243)
            using wwdgen = bit::field<11>;
            // TIM14 clock enable (rm page 243)
            using tim14en = bit::field<8>;
            // TIM13 clock enable (rm page 243)
            using tim13en = bit::field<7>;
            // TIM12 clock enable (rm page 243)
            using tim12en = bit::field<6>;
            // TIM7 clock enable (rm page 243)
            using tim7en = bit::field<5>;
            // TIM6 clock enable (rm page 243)
            using tim6en = bit::field<4>;
            // TIM5 clock enable (rm page 243)
            using tim5en = bit::field<3>;
            // TIM4 clock enable (rm page 244)
            using tim4en = bit::field<2>;
            // TIM3 clock enable (rm page 244)
            using tim3en = bit::field<1>;
            // TIM2 clock enable (rm page 244)
            using tim2en = bit::field<0>;
        }
        // RCC APB2 peripheral clock enable register [offset: 0x44, reset: 0x0000 0000]
        namespace apb2enr {
            // TIM11 clock enable (rm page 244)
            using tim11en = bit::field<18>;
            // TIM10 clock enable (rm page 244)
            using tim10en = bit::field<17>;
            // TIM9 clock enable (rm page 244)
            using tim9en = bit::field<16>;
            // System configuration controller clock enable (rm page 245)
            using syscfgen = bit::field<14>;
            // SPI1 clock enable (rm page 245)
            using spi1en = bit::field<12>;
            // SDIO clock enable (rm page 245)
            using sdioen = bit::field<11>;
            // ADC3 clock enable (rm page 245)
            using adc3en = bit::field<10>;
            // ADC2 clock enable (rm page 245)
            using adc2en = bit::field<9>;
            // ADC1 clock enable (rm page 245)
            using adc1en = bit::field<8>;
            // USART6 clock enable (rm page 245)
            using usart6en = bit::field<5>;
            // USART1 clock enable (rm page 245)
            using usart1en = bit::field<4>;
            // TIM8 clock enable (rm page 245)
            using tim8en = bit::field<1>;
            // TIM1 clock enable (rm page 245)
            using tim1en = bit::field<0>;
        }
        // RCC AHB1 peripheral clock enable in low power mode register [offset: 0x50, reset: 0x7E67 91FF]
        namespace ahb1lpenr {
            // USB OTG HS ULPI clock enable during Sleep mode (rm page 248)
            using otghsulpilpen = bit::field<30>;
            // USB OTG HS clock enable during Sleep mode (rm page 248)
            using otghslpen = bit::field<29>;
            // Ethernet PTP clock enable during Sleep mode (rm page 248)
            using ethmacptplpen = bit::field<28>;
            // Ethernet reception clock enable during Sleep mode (rm page 248)
            using ethmacrxlpen = bit::field<27>;
            // Ethernet transmission clock enable during Sleep mode (rm page 248)
            using ethmactxlpen = bit::field<26>;
            // Ethernet MAC clock enable during Sleep mode (rm page 248)
            using ethmaclpen = bit::field<25>;
            // DMA2 clock enable during Sleep mode (rm page 248)
            using dma2lpen = bit::field<22>;
            // DMA1 clock enable during Sleep mode (rm page 249)
            using dma1lpen = bit::field<21>;
            // Backup SRAM interface clock enable during Sleep mode (rm page 249)
            using bkpsramlpen = bit::field<18>;
            // SRAM 2 interface clock enable during Sleep mode (rm page 249)
            using sram2lpen = bit::field<17>;
            // SRAM 1interface clock enable during Sleep mode (rm page 249)
            using sram1lpen = bit::field<16>;
            // Flash interface clock enable during Sleep mode (rm page 249)
            using flitflpen = bit::field<15>;
            // CRC clock enable during Sleep mode (rm page 249)
            using crclpen = bit::field<12>;
            // IO port I clock enable during Sleep mode (rm page 249)
            using gpioilpen = bit::field<8>;
            // IO port H clock enable during Sleep mode (rm page 249)
            using gpiohlpen = bit::field<7>;
            // IO port F clock enable during Sleep mode (rm page 249)
            using gpioflpen = bit::field<5>;
            // IO port E clock enable during Sleep mode (rm page 250)
            using gpioelpen = bit::field<4>;
            // IO port D clock enable during Sleep mode (rm page 250)
            using gpiodlpen = bit::field<3>;
            // IO port C clock enable during Sleep mode (rm page 250)
            using gpioclpen = bit::field<2>;
            // IO port B clock enable during Sleep mode (rm page 250)
            using gpioblpen = bit::field<1>;
            // IO port A clock enable during sleep mode (rm page 250)
            using gpioalpen = bit::field<0>;
        }
        // RCC AHB2 peripheral clock enable in low power mode register [offset: 0x54, reset: 0x0000 00F1]
        namespace ahb2lpenr {
            // USB OTG FS clock enable during Sleep mode (rm page 250)
            using otgfslpen = bit::field<7>;
            // Random number generator clock enable during Sleep mode (rm page 250)
            using rnglpen = bit::field<6>;
            // Hash modules clock enable during Sleep mode (rm page 251)
            using hashlpen = bit::field<5>;
            // Cryptography modules clock enable during Sleep mode (rm page 251)
            using cryplpen = bit::field<4>;
            // Camera interface enable during Sleep mode (rm page 251)
            using dcmilpen = bit::field<0>;
        }
        // RCC AHB3 peripheral clock enable in low power mode register [offset: 0x58, reset: 0x0000 0001]
        namespace ahb3lpenr {
            // Flexible static memory controller module clock enable during Sleep mode (rm page 251)
            using fsmclpen = bit::field<0>;
        }
        // RCC APB1 peripheral clock enable in low power mode register [offset: 0x60, reset: 0x36FE C9FF]
        namespace apb1lpenr {
            // DAC interface clock enable during Sleep mode (rm page 252)
            using daclpen = bit::field<29>;
            // Power interface clock enable during Sleep mode (rm page 252)
            using pwrlpen = bit::field<28>;
            // CAN 2 clock enable during Sleep mode (rm page 252)
            using can2lpen = bit::field<26>;
            // CAN 1 clock enable during Sleep mode (rm page 252)
            using can1lpen = bit::field<25>;
            // I2C3 clock enable during Sleep mode (rm page 252)
            using i2c3lpen = bit::field<23>;
            // I2C2 clock enable during Sleep mode (rm page 252)
            using i2c2lpen = bit::field<22>;
            // I2C1 clock enable during Sleep mode (rm page 253)
            using i2c1lpen = bit::field<21>;
            // UART5 clock enable during Sleep mode (rm page 253)
            using uart5lpen = bit::field<20>;
            // UART4 clock enable during Sleep mode (rm page 253)
            using uart4lpen = bit::field<19>;
            // USART3 clock enable during Sleep mode (rm page 253)
            using usart3lpen = bit::field<18>;
            // USART2 clock enable during Sleep mode (rm page 253)
            using usart2lpen = bit::field<17>;
            // SPI3 clock enable during Sleep mode (rm page 253)
            using spi3lpen = bit::field<15>;
            // SPI2 clock enable during Sleep mode (rm page 253)
            using spi2lpen = bit::field<14>;
            // Window watchdog clock enable during Sleep mode (rm page 253)
            using wwdglpen = bit::field<11>;
            // TIM14 clock enable during Sleep mode (rm page 253)
            using tim14lpen = bit::field<8>;
            // TIM13 clock enable during Sleep mode (rm page 253)
            using tim13lpen = bit::field<7>;
            // TIM12 clock enable during Sleep mode (rm page 254)
            using tim12lpen = bit::field<6>;
            // TIM7 clock enable during Sleep mode (rm page 254)
            using tim7lpen = bit::field<5>;
            // TIM6 clock enable during Sleep mode (rm page 254)
            using tim6lpen = bit::field<4>;
            // TIM5 clock enable during Sleep mode (rm page 254)
            using tim5lpen = bit::field<3>;
            // TIM4 clock enable during Sleep mode (rm page 254)
            using tim4lpen = bit::field<2>;
            // TIM3 clock enable during Sleep mode (rm page 254)
            using tim3lpen = bit::field<1>;
            // TIM2 clock enable during Sleep mode (rm page 254)
            using tim2lpen = bit::field<0>;
        }
        // RCC APB2 peripheral clock enabled in low power mode register [offset: 0x64, reset: 0x0007 5F33]
        namespace apb2lpenr {
            // TIM11 clock enable during Sleep mode (rm page 255)
            using tim11lpen = bit::field<18>;
            // TIM10 clock enable during Sleep mode (rm page 255)
            using tim10lpen = bit::field<17>;
            // TIM9 clock enable during sleep mode (rm page 255)
            using tim9lpen = bit::field<16>;
            // System configuration controller clock enable during Sleep mode (rm page 255)
            using syscfglpen = bit::field<14>;
            // SPI1 clock enable during Sleep mode (rm page 255)
            using spi1lpen = bit::field<12>;
            // SDIO clock enable during Sleep mode (rm page 255)
            using sdiolpen = bit::field<11>;
            // ADC 3 clock enable during Sleep mode (rm page 256)
            using adc3lpen = bit::field<10>;
            // ADC2 clock enable during Sleep mode (rm page 256)
            using adc2lpen = bit::field<9>;
            // ADC1 clock enable during Sleep mode (rm page 256)
            using adc1lpen = bit::field<8>;
            // USART6 clock enable during Sleep mode (rm page 256)
            using usart6lpen = bit::field<5>;
            // USART1 clock enable during Sleep mode (rm page 256)
            using usart1lpen = bit::field<4>;
            // TIM8 clock enable during Sleep mode (rm page 256)
            using tim8lpen = bit::field<1>;
            // TIM1 clock enable during Sleep mode (rm page 256)
            using tim1lpen = bit::field<0>;
        }
        // RCC Backup domain control register [offset: 0x70, reset: 0x0000 0000]
        namespace bdcr {
            // Backup domain software reset (rm page 257)
            using bdrst = bit::field<16>;
            // RTC clock enable (rm page 257)
            using rtcen = bit::field<15>;
            // RTC clock source selection (rm page 257)
            using rtcsel = bit::field<9, 8>;
            // External low-speed oscillator bypass (rm page 258)
            using lsebyp = bit::field<2>;
            // External low-speed oscillator ready (rm page 258)
            using lserdy = bit::field<1>;
            // External low-speed oscillator enable (rm page 258)
            using lseon = bit::field<0>;
        }
        // RCC clock control & status register [offset: 0x74, reset: 0x0E00 0000]
        namespace csr {
            // Low-power reset flag (rm page 258)
            using lpwrrstf = bit::field<31>;
            // Window watchdog reset flag (rm page 258)
            using wwdgrstf = bit::field<30>;
            // Independent watchdog reset flag (rm page 258)
            using iwdgrstf = bit::field<29>;
            // Software reset flag (rm page 259)
            using sftrstf = bit::field<28>;
            // POR/PDR reset flag (rm page 259)
            using porrstf = bit::field<27>;
            // PIN reset flag (rm page 259)
            using pinrstf = bit::field<26>;
            // BOR reset flag (rm page 259)
            using borrstf = bit::field<25>;
            // Remove reset flag (rm page 259)
            using rmvf = bit::field<24>;
            // Internal low-speed oscillator ready (rm page 259)
            using lsirdy = bit::field<1>;
            // Internal low-speed oscillator enable (rm page 259)
            using lsion = bit::field<0>;
        }
        // RCC spread spectrum clock generation register [offset: 0x80, reset: 0x0000 0000]
        namespace sscgr {
            // Spread spectrum modulation enable (rm page 260)
            using sscgen = bit::field<31>;
            // Spread Select (rm page 260)
            using spreadsel = bit::field<30>;
            // Incrementation step (rm page 260)
            using incstep = bit::field<27, 13>;
            // Modulation period (rm page 260)
            using modper = bit::field<12, 0>;
        }
        // RCC PLLI2S configuration register [offset: 0x84, reset: 0x2000 3000]
        namespace plli2scfgr {
            // PLLI2S division factor for I2S clocks (rm page 261)
            using plli2sr = bit::field<30, 28>;
            // PLLI2S multiplication factor for VCO (rm page 262)
            using plli2sn = bit::field<14, 6>;
        }
    } // namespace fields

    struct register_map {
        // CR: RCC clock control register (rm page 220)
        bit::register_base cr;
        // PLLCFGR: RCC PLL configuration register (rm page 222)
        bit::register_base pllcfgr;
        // CFGR: RCC clock configuration register (rm page 224)
        bit::register_base cfgr;
        // CIR: RCC clock interrupt register (rm page 226)
        bit::register_base cir;
        // AHB1RSTR: RCC AHB1 peripheral reset register (rm page 229)
        bit::register_base ahb1rstr;
        // AHB2RSTR: RCC AHB2 peripheral reset register (rm page 232)
        bit::register_base ahb2rstr;
        // AHB3RSTR: RCC AHB3 peripheral reset register (rm page 233)
        bit::register_base ahb3rstr;
        uint32 zzzoffset0;
        // APB1RSTR: RCC APB1 peripheral reset register (rm page 233)
        bit::register_base apb1rstr;
        // APB2RSTR: RCC APB2 peripheral reset register (rm page 236)
        bit::register_base apb2rstr;
        uint8 zzzoffset1[8];
        // AHB1ENR: RCC AHB1 peripheral clock enable register (rm page 238)
        bit::register_base ahb1enr;
        // AHB2ENR: RCC AHB2 peripheral clock enable register (rm page 240)
        bit::register_base ahb2enr;
        // AHB3ENR: RCC AHB3 peripheral clock enable register (rm page 241)
        bit::register_base ahb3enr;
        uint32 zzzoffset2;
        // APB1ENR: RCC APB1 peripheral clock enable register (rm page 241)
        bit::register_base apb1enr;
        // APB2ENR: RCC APB2 peripheral clock enable register (rm page 244)
        bit::register_base apb2enr;
        uint8 zzzoffset3[8];
        // AHB1LPENR: RCC AHB1 peripheral clock enable in low power mode register (rm page 248)
        bit::register_base ahb1lpenr;
        // AHB2LPENR: RCC AHB2 peripheral clock enable in low power mode register (rm page 250)
        bit::register_base ahb2lpenr;
        // AHB3LPENR: RCC AHB3 peripheral clock enable in low power mode register (rm page 251)
        bit::register_base ahb3lpenr;
        uint32 zzzoffset4;
        // APB1LPENR: RCC APB1 peripheral clock enable in low power mode register (rm page 252)
        bit::register_base apb1lpenr;
        // APB2LPENR: RCC APB2 peripheral clock enabled in low power mode register (rm page 255)
        bit::register_base apb2lpenr;
        uint8 zzzoffset5[8];
        // BDCR: RCC Backup domain control register (rm page 257)
        bit::register_base bdcr;
        // CSR: RCC clock control & status register (rm page 258)
        bit::register_base csr;
        uint8 zzzoffset6[8];
        // SSCGR: RCC spread spectrum clock generation register (rm page 260)
        bit::register_base sscgr;
        // PLLI2SCFGR: RCC PLLI2S configuration register (rm page 261)
        bit::register_base plli2scfgr;
    };

#if __GNUC__ == 4 && __GNUC_MINOR__ == 9

    extern "C" register_map __rcc__device_0x40023800;
    static auto& device = __rcc__device_0x40023800;

#else

    static auto& device = util::reference<register_map, 0x40023800>::value;

#endif

} // namespace rcc

#endif
